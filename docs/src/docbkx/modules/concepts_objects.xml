<section id="system_obj">
    <title>Operational Data</title>
    <para>Blah blah blah intro</para>

    <section id="obj_meas">
        <title>Measurements</title>
        <para>
            <emphasis>Measurements</emphasis> are the basic units of data published by <emphasis>data sources</emphasis> and processed and
            monitored by the system. Often, measurements are acquired using communications protocols, and are used
            to represent the state of remote <emphasis>field devices</emphasis>. Measurements may also be generated by
            applications or manually entered by users.</para>

        <para>Measurements carry the following data fields:</para>
        <itemizedlist>
            <listitem>
                <para><emphasis>Value</emphasis> can be of type boolean (<emphasis>status</emphasis>,
                    <emphasis>binary input</emphasis>), integer or floating point (<emphasis>analog</emphasis>,
                    <emphasis>analog input</emphasis>), or text string. This is the central data payload of
                    the measurement.
                </para>
            </listitem>
            <listitem>
                <para><emphasis>Quality</emphasis> gives users and applications extra information about the state of the
                    measurement. Quality may indicate problems with end devices, communications issues, or operator
                    influence ("blocked").
                </para>
            </listitem>
            <listitem>
                <para><emphasis>Time</emphasis> identifies when the measurement took place, or when it was acquired by
                    the communications system.
                </para>
            </listitem>
            <listitem>
                <para><emphasis>Unit</emphasis> gives the measurement value real-world meaning. Examples are "volt", "psi",
                    etc. Additionally, unit carries an implicit definition of scale.
                </para>
            </listitem>
        </itemizedlist>
        <para>
           Measurements enter the system either from communication <emphasis>front-ends</emphasis> or directly using the Reef
            APIs. The measurement <emphasis>stream</emphasis> is then processed -- configured transformations
            are applied (scaling, value mapping) and side-effects are triggered (event/alarm generation) . Finally, measurements are stored in
            the database and published to the bus.
        </para>
        <para>
           Many system functions are concerned with maintaining the most recent value for any given measurement in order to
            provide an up-to-date representation of system devices and components. The system also maintains
            <emphasis>measurement history</emphasis>, the chronological stream of previous measurement values.
        </para>
    </section>
    <section id="obj_meas">
        <title>Commands</title>
        <para><emphasis>Commands</emphasis> are the indications users and applications use to interact with and modify the state of the system. Commonly,
        commands are tunneled by the communications processors to remote field devices in order to exercise control over their
        functions. Whereas measurements constitute the flow of data from the field, commands form the information moving outwards.</para>

        <para>Commands may or may not contain an associated value. In the field communications world, commands with values are usually
        referred to as <emphasis>setpoints</emphasis>, and may refer to a <emphasis>target value</emphasis> the system or end device
        is intended to reach. Values are therefore used when a simple imperative cannot convey the proper message, such as
        "set temperature to 65 degrees celsius".</para>

        <para>
            When multiple users and applications may be using the system concurrently, simultaneously making modifications to the same
            subsystems can lead to undesired results and indeterminate behavior. Furthermore, it is frequently the case that some field
            devices need to be declared "off limits" for safety or maintenance reasons. The following objects are used to regulate access to commands:
        </para>
        <itemizedlist>
            <listitem>
                <para><emphasis>Selects</emphasis> are acquired by users and applications to grant exclusive access to a command or
                    set of commands.
                </para>
            </listitem>
            <listitem>
                <para><emphasis>Blocks</emphasis> are used to prevent <emphasis>any</emphasis> user or application from accessing a
                    command or set of commands.
                </para>
            </listitem>
        </itemizedlist>
        <para>

        </para>
    </section>
    <section id="obj_meas">
        <title>Events</title>
        <para><emphasis>Events</emphasis> are objects that record a meaningful occurrence or change of state in the system. They are used both
            to monitor the system in real-time and to provide an audit log of system history.
        </para>
        <para>Events are configured with the parameters
            <emphasis>type</emphasis> and <emphasis>severity</emphasis>, and contain context
            information like the originating subsystem and associated user. The "message" of the event may contain a
            further description, and contain any relevant data attributes.
        </para>
         <para>
             Ultimately, the definition of events, as well as the conditions under which they are triggered, are highly
         configurable. Events, as a whole, are a tool system designers use to characterize system behavior and to
             provide users, applications, and administrators the information needed.
         </para>
        <para>
            While most measurement updates will not cause events (due to their high volume and redundancy), updates that fall
            outside <emphasis>reasonable</emphasis> or <emphasis>nominal</emphasis> values may constitute a system-notable
            change and trigger an event.
        </para>
        <para>
            Many or most commands issued by users and applications will qualify as events. Other events may not be tied to
            operational data, but instead will record system activity such as application errors and user log-in.
        </para>
    </section>
    <section id="obj_meas">
        <title>Alarms</title>
        <para>
            <emphasis>Alarms</emphasis> are a refinement of events which identify system occurrences that require operator intervention.
            Alarm objects are tied closely to event objects. All alarms are associated with events, but not all events cause alarms.
        </para>



        <para>In contrast to events, alarms have persistent state. The three principal alarm states are <emphasis>unacknowledged</emphasis>,
            <emphasis>acknowledged</emphasis>, and <emphasis>removed</emphasis>. The transitions between these states constitute the
            <emphasis>alarm lifecycle</emphasis>, and manipulation of the states involves user <emphasis>workflow</emphasis>.
            Transitions in alarm state may themselves be events, as they are part of the record of user operations.
        </para>

        <figure id="event_alarms">
            <title>Relationship between Alarm and Event</title>
            <mediaobject>
                <imageobject>
                    <imagedata align="center" fileref="images/eventalarmsmall.png"/>
                </imageobject>
            </mediaobject>
        </figure>

        <para>
            During the configuration process, the system designer decides what events trigger alarms. The primary consumers of
            alarms are operators tasked with monitoring the system in real-time and responding to abnormal conditions.
        </para>
    </section>

</section>
